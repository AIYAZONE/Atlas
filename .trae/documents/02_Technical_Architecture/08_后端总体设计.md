## 目标

- **MVP 阶段**：采用“Java 对外入口 + Node 渲染发布”的最小混合方案，快速闭环与快速迭代
- **后续阶段**：在不改变“前台纯静态交付”的前提下，通过缓存、队列与治理能力提升可靠性与扩展性
- 始终保持前后分离与纯静态发布，S3 + CloudFront 架构不变

## MVP 阶段：最小混合架构（Java + Node）

- **核心理念**：把“对外治理与业务编排”交给 Java，把“渲染与构建链路复用 TypeScript”交给 Node

### 架构映射

- **Database**：PostgreSQL（JSONB 存储 Page Schema 与页面实例）
- **Auth**：OIDC（Keycloak 或企业 SSO），统一鉴权与审计
- **API（对外唯一入口）**：Java Backend（REST + OpenAPI）
- **Commerce**：Java 代理 Shopify API（Cart Checkout）并接收订单 Webhook 入库
- **Preview**：Node Preview Service（复用 TS 渲染库），由 Java 触发
- **Publisher**：Node Worker（任务方式运行），读 DB 渲染静态产物并写入 S3，刷新 CDN

## Scale 阶段：增强可靠性与并发

- **触发条件**：发布频率增大、构建耗时增大、预览并发增大、需要更强的幂等与重试能力
- **增强点**：
  - Redis：缓存与去抖（预览、Shopify 访问、构建状态）
  - Queue Event：发布任务异步化、重试与死信队列、削峰填谷
  - Observability：指标、日志、链路追踪统一

## 模块与项目结构（建议）

- Java（单体模块化）
  - api-gateway：统一入口（REST + OpenAPI）、鉴权、审计、错误处理
  - builder：编辑协调（草稿、预览与发布触发）
  - commerce：购物车、结算、订单 Webhook、幂等与对账
  - adapters-shopify：限流、重试、签名校验、数据适配
  - storage：DAO 与仓储（JSONB 读写、版本、备份）
  - auth：OIDC 集成与 RBAC
- Node（内部能力服务）
  - renderer：TS 渲染库（前端与构建共享）
  - preview：常驻预览服务
  - publisher-worker：构建发布 Worker（任务运行）

## 部署与运行

- Java Backend：ECS Fargate 常驻服务，水平扩展，滚动发布
- Node Preview：ECS Fargate 常驻服务（减少预览冷启动）
- Node Worker：ECS Task 按需运行（并发与资源可控）
- 静态站点：S3 + CloudFront；Route53/ACM；VPC/IAM/SSM（最小权限）

## 数据与事件

- PostgreSQL：页面与配置 JSONB；订单摘要与业务数据可规范化
- Redis（可选）：会话、短期缓存、构建状态
- Queue Event（可选）：发布任务、重试、死信队列

## 演进路线（MVP 优先）

- Phase 1：Java API + Node Preview + Node Worker，跑通编辑 预览 发布 访问 交易闭环
- Phase 2：引入 Redis 与 Queue Event，发布与构建可观测、可重试、可回滚
- Phase 3：按需拆分高吞吐模块与插件沙箱，保持前台纯静态交付不变

## 风险与缓解

- Java 与 Node 协作边界不清：以“Java 对外唯一入口 + Node 内部能力”固定边界
- 契约漂移（TS 与 Java 双写）：MVP 先跑通闭环，Scale 阶段引入契约生成（OpenAPI 或 JSON Schema）
- 构建链路可靠性：引入幂等键、重试策略与死信队列（Scale 阶段）

## 文档修订（已对齐）

- 架构图与技术口径统一为 Java + Node 最小混合

## 验收标准（MVP）

- Java API 稳定运行（鉴权、页面 CRUD、Shopify 代理与 Webhook 入库）
- Node 预览与构建链路稳定（可观测、失败可重试）
- 前台保持纯静态交付（无 Node Runtime）
