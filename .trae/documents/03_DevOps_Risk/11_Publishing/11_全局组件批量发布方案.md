# 全局组件批量发布方案（1000页静态站）

## 背景与目标
- Atlas 是内部系统，但用它搭建发布的站点面向普通消费者（外部网站）。
- 因此全局组件（Header/Footer/Cookie Banner）的更新需要同时满足：
  - SEO 与可抓取（Header/Footer 通常承载导航与站内链接）
  - 首屏稳定与性能（不能明显拖慢 LCP）
  - 发布可控、可回滚、可审计（企业级治理）

## 结论（先给可执行答案）
- Header/Footer：默认走“全站批量发布（Site Publish Job）+ 版本化目录 + 原子切换”。
- Cookie Banner：独立脚本与配置下发，不触发全站重建。
- 可选高级优化：CDN 边缘 HTML 重写（CloudFront Functions/Lambda@Edge）用于高频小改动，但必须保留批量重建作为兜底。

## 为什么需要批量发布
如果 Header/Footer 的 HTML 被内联进每个页面的输出 HTML，那么更新全局组件就必须重建所有引用它的页面，否则页面仍然是旧 Header/Footer。这和“每页独立静态页”并不矛盾，反而说明发布系统要能批量治理。

## 默认方案A：全站批量发布（构建期内联）
### 1) 全局组件建模
- 把 Header/Footer/Cookie Banner 存成站点级资源（site scope），包含 version 或 hash。
- 页面构建指纹包含 header_version/footer_version/banner_version，用于判定是否需要重建。

### 2) 依赖索引（决定受影响页面集合）
- 维护 dependency index：component_id -> [page_id...]。
- 对 Header/Footer：默认依赖集就是全站（1000页）。
- 对其他公共组件：依赖集可以是子集（只在部分页面出现）。

### 3) 发布任务（Job）与进度面板
- Java 创建 publish_job，计算受影响 pages，写入 job_items（page_id 列表）。
- API 立即返回 jobId（异步），前端展示进度、支持取消/重试/回滚。

### 4) Worker 批量构建（并发可控）
- Worker 按 batch 拉取 job_items：每批 50-200 页（按渲染耗时调整）。
- 并发建议：站点级 inflight job 1-2；单 worker render_concurrency 4（CPU够再升 8）。
- Shopify/外部依赖访问需要全局限流（避免 429）。

### 5) 版本化发布与原子切换（避免逐页 CDN Invalidate）
- 输出到 releases/{version}/...（不可变目录）。
- 发布完成后切换当前版本指针（例如更新 current.json 或 CloudFront origin path/函数映射）。
- 回滚=切回旧指针，分钟级完成，不需要对 1000 个 URL 逐条失效。

## 可选方案B：CDN 边缘 HTML 重写（高频小改动）
### 做法
- 将 Header/Footer 作为独立片段（fragment）按版本发布到对象存储。
- CDN 边缘根据站点配置版本注入或替换 Header/Footer 片段，返回给爬虫与用户的仍是完整 HTML。

### 优点
- 不重建 1000 页也能更换全局组件，变更生效更快。
- 回滚更快（切换 fragment 版本或配置版本）。

### 风险与约束
- 边缘脚本引入复杂性与成本，需要严格测试与监控。
- 需要明确缓存策略（片段版本化、HTML 可控缓存），避免旧缓存混用。
- 对个性化逻辑与 Cookie 处理必须谨慎（尽量保持片段纯静态）。

## Cookie Banner 的推荐做法（不触发全站重建）
- Cookie Banner 最适合独立 JS bundle + 配置下发（按 region/语言切换也更自然）。
- Banner 更新只需发布脚本与配置，HTML 不必重建。

## 操作指引（面向运营）
1) 更新 Header/Footer 组件版本（站点级资源版本变更）。
2) 点击“全站发布”，系统创建 job 并返回 jobId。
3) 观察进度与失败原因，必要时重试或取消。
4) 发布完成后原子切换版本；如异常一键回滚到上一版本。

## 关联文档
- 发布与SLA默认参数与回滚策略：见 10_SLA与发布体系（99.9_10000页）.md
